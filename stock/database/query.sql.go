// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addStockReservation = `-- name: AddStockReservation :exec
insert into products.stock_reservations (id, product_id, order_number, quantity, create_date, cancel_date) values ($1, $2, $3, $4, $5, $6)
`

type AddStockReservationParams struct {
	ID          uuid.UUID
	ProductID   uuid.UUID
	OrderNumber uuid.UUID
	Quantity    int32
	CreateDate  time.Time
	CancelDate  *time.Time
}

func (q *Queries) AddStockReservation(ctx context.Context, arg AddStockReservationParams) error {
	_, err := q.db.Exec(ctx, addStockReservation,
		arg.ID,
		arg.ProductID,
		arg.OrderNumber,
		arg.Quantity,
		arg.CreateDate,
		arg.CancelDate,
	)
	return err
}

const cancelStockReservation = `-- name: CancelStockReservation :exec
update products.stock_reservations set cancel_date = $1 where id = $2
`

type CancelStockReservationParams struct {
	Canceldate *time.Time
	ID         uuid.UUID
}

func (q *Queries) CancelStockReservation(ctx context.Context, arg CancelStockReservationParams) error {
	_, err := q.db.Exec(ctx, cancelStockReservation, arg.Canceldate, arg.ID)
	return err
}

const getStock = `-- name: GetStock :one
select s.id, s.product_id, s.quantity, s.reserved_quantity, s.version, s.create_date, s.last_update_date from products.stocks s where s.product_id = $1
`

type GetStockRow struct {
	Stock Stock
}

func (q *Queries) GetStock(ctx context.Context, productid uuid.UUID) (GetStockRow, error) {
	row := q.db.QueryRow(ctx, getStock, productid)
	var i GetStockRow
	err := row.Scan(
		&i.Stock.ID,
		&i.Stock.ProductID,
		&i.Stock.Quantity,
		&i.Stock.ReservedQuantity,
		&i.Stock.Version,
		&i.Stock.CreateDate,
		&i.Stock.LastUpdateDate,
	)
	return i, err
}

const getStockReservation = `-- name: GetStockReservation :one
select sr.id, sr.product_id, sr.order_number, sr.quantity, sr.create_date, sr.cancel_date from products.stock_reservations sr where sr.order_number = $1 and cancel_date is null
`

type GetStockReservationRow struct {
	StockReservation StockReservation
}

func (q *Queries) GetStockReservation(ctx context.Context, ordernumber uuid.UUID) (GetStockReservationRow, error) {
	row := q.db.QueryRow(ctx, getStockReservation, ordernumber)
	var i GetStockReservationRow
	err := row.Scan(
		&i.StockReservation.ID,
		&i.StockReservation.ProductID,
		&i.StockReservation.OrderNumber,
		&i.StockReservation.Quantity,
		&i.StockReservation.CreateDate,
		&i.StockReservation.CancelDate,
	)
	return i, err
}

const getStocks = `-- name: GetStocks :many
select id, product_id, quantity, reserved_quantity, version, create_date, last_update_date from products.stocks
where ($1::uuid is null or product_id = $1::uuid) 
  and (
    ($2::timestamp is null or create_date > $2::timestamp)
     and ($3::timestamp is null or create_date < $3::timestamp)
     )
`

type GetStocksParams struct {
	ProductID pgtype.UUID
	From      *time.Time
	To        *time.Time
}

func (q *Queries) GetStocks(ctx context.Context, arg GetStocksParams) ([]Stock, error) {
	rows, err := q.db.Query(ctx, getStocks, arg.ProductID, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stock
	for rows.Next() {
		var i Stock
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Quantity,
			&i.ReservedQuantity,
			&i.Version,
			&i.CreateDate,
			&i.LastUpdateDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insert = `-- name: Insert :exec
insert into products.stocks (id, product_id, quantity, reserved_quantity, version, create_date, last_update_date) 
values ($1, $2, $3, $4, $5, $6, $7)
`

type InsertParams struct {
	ID               uuid.UUID
	ProductID        uuid.UUID
	Quantity         int32
	ReservedQuantity int32
	Version          int32
	CreateDate       time.Time
	LastUpdateDate   time.Time
}

func (q *Queries) Insert(ctx context.Context, arg InsertParams) error {
	_, err := q.db.Exec(ctx, insert,
		arg.ID,
		arg.ProductID,
		arg.Quantity,
		arg.ReservedQuantity,
		arg.Version,
		arg.CreateDate,
		arg.LastUpdateDate,
	)
	return err
}

const stockReservationExists = `-- name: StockReservationExists :one
select exists(select 1 from products.stock_reservations where order_number = $1 and cancel_date is null)
`

func (q *Queries) StockReservationExists(ctx context.Context, ordernumber uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, stockReservationExists, ordernumber)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateStockQuantity = `-- name: UpdateStockQuantity :exec
update products.stocks set quantity = $1, version = version+1 where id = $2 and version = $3
`

type UpdateStockQuantityParams struct {
	Quantity int32
	ID       uuid.UUID
	Version  int32
}

func (q *Queries) UpdateStockQuantity(ctx context.Context, arg UpdateStockQuantityParams) error {
	_, err := q.db.Exec(ctx, updateStockQuantity, arg.Quantity, arg.ID, arg.Version)
	return err
}

const updateStockReserve = `-- name: UpdateStockReserve :exec
update products.stocks set reserved_quantity = $1, version = version+1 where id = $2 and version = $3
`

type UpdateStockReserveParams struct {
	Reservedquantity int32
	ID               uuid.UUID
	Version          int32
}

func (q *Queries) UpdateStockReserve(ctx context.Context, arg UpdateStockReserveParams) error {
	_, err := q.db.Exec(ctx, updateStockReserve, arg.Reservedquantity, arg.ID, arg.Version)
	return err
}
